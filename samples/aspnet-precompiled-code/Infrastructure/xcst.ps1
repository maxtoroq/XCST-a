param(
   [Parameter(Mandatory = $true)]
   [string]$ProjectPath,
   [Parameter(Mandatory = $true)]
   [string]$Configuration
)

$ErrorActionPreference = "Stop"

# Use the project's path as base to resolve relative paths
Push-Location (Split-Path $ProjectPath)

$fileExt = "xcst"
$nugetPackages = Resolve-Path ..\..\packages

# Loading project dependencies enables referencing packages from other projects
function LoadProjectDependencies {

   foreach ($ref in $projDoc.Project.ItemGroup.ProjectReference | where { $_ -ne $null }) {

      $refDir = Split-Path $ref.Include
      $refDll = Resolve-Path (Join-Path $refDir bin\$Configuration\$($ref.Name).dll)

      #Write-Host "XCST/Loading: $(Resolve-Path $refDll -Relative)"
      $asm = [Reflection.Assembly]::LoadFrom($refDll.Path)
   }
}

# PowerShell doesn't seem to load types unless they are assembly-qualified
# We fix it by looking in each loaded assembly individually
# We also make sure the same type does not exist in different assemblies
function FindCompiledPackage([string]$packageName) {

   $type = $null

   foreach ($asm in [AppDomain]::CurrentDomain.GetAssemblies())	{

      $type2 = $asm.GetType($packageName)

      if ($type2 -ne $null) {

         if ($type -ne $null -and $type2 -ne $type) {
            throw "Ambiguous type '$packageName'"
         }

         $type = $type2
      }
   }

   return $type
}

# Show compilation errors on Visual Studio's Error List
# Also makes the error on the Output window clickable
function VisualStudioErrorLog([Xcst.Compiler.CompileException]$ex) {

   $uriString = $ex.ModuleUri
   $uri = New-Object Uri $uriString
   $path = if ($uri.IsFile) { $uri.LocalPath } else { $uriString }
   $lineNum = $ex.LineNumber
   $code = $ex.ErrorCode
   $message = $ex.Message

   Write-Host "$path($lineNum): XCST error $($code): $message"
}

# Transforms invalid identifier (class, namespace, variable) characters
function CleanIdentifier($identifier) {
   $identifier -ireplace "[^a-z0-9_.]", "_"
}

# Main function
function GeneratePackages([IO.TextWriter]$output) {

   try {

      [xml]$projDoc = Get-Content $ProjectPath

      $namespace = $projDoc.Project.PropertyGroup[0].RootNamespace

      # AssemblyResolve is used to enable loading (newer versions of) Xcst.Compiler's dependencies
      $onAssemblyResolve = [ResolveEventHandler] {
         param($sender, $e)

         $assemblyName = $e.Name.Split(',')[0]
         $assemblyPath = "$nugetPackages\$assemblyName.*\lib\net46\$assemblyName.dll"

         if ($assemblyName.StartsWith("saxon9he") -or $assemblyName.StartsWith("IKVM.")) {
            $assemblyPath = "$nugetPackages\Saxon-HE.*\lib\net40\$assemblyName.dll"
         }

         if (-not (Test-Path $assemblyPath)) {
            return $null
         }

         return [Reflection.Assembly]::LoadFrom((Resolve-Path $assemblyPath))
      }

      [AppDomain]::CurrentDomain.add_AssemblyResolve($onAssemblyResolve)

      # Load compiler
      Add-Type -Path $nugetPackages\Xcst.Compiler.*\lib\net46\Xcst.Compiler.dll

      $compilerFact = New-Object Xcst.Compiler.XcstCompilerFactory
      $compilerFact.EnableExtensions = $true

      # Enable "application" extension
      #$appExtension = [Reflection.Assembly]::LoadFrom((Resolve-Path $nugetPackages\Xcst.AspNet.Extension.*\lib\net46\Xcst.AspNet.Extension.dll))
      $appExtension = [Reflection.Assembly]::LoadFrom((Resolve-Path ..\..\src\Xcst.AspNet.Extension\bin\$Configuration\Xcst.AspNet.Extension.dll))
      $compilerFact.RegisterExtensionsForAssembly($appExtension)

      LoadProjectDependencies

      $output.WriteLine("//------------------------------------------------------------------------------")
      $output.WriteLine("// <auto-generated>")
      $output.WriteLine("//     This code was generated by a tool.")
      $output.WriteLine("//")
      $output.WriteLine("//     Changes to this file may cause incorrect behavior and will be lost if")
      $output.WriteLine("//     the code is regenerated.")
      $output.WriteLine("// </auto-generated>")
      $output.WriteLine("//------------------------------------------------------------------------------")
      $output.WriteLine()
      $output.WriteLine("[assembly: global::AspNetPrecompiled.Infrastructure.PrecompiledModule]")

      $startDir = Get-Item .
      $startUri = New-Object Uri ($startDir.FullName + [IO.Path]::DirectorySeparatorChar)

      foreach ($file in ls $startDir *.$fileExt -Recurse) {

         # Ignore files starting with underscore
         if ($file.Name[0] -eq '_') {
            continue
         }

         $compiler = $compilerFact.CreateCompiler()
         $compiler.PackagesLocation = $startDir.FullName
         $compiler.PackageFileExtension = $fileExt
         $compiler.IndentChars = "   "

         $compiler.PackageTypeResolver = [Func[[string], [Type]]] {
            param($packageName)

            return FindCompiledPackage $packageName
         }

         $relativePath = $startUri.MakeRelativeUri((New-Object Uri $file.FullName)).OriginalString

         # Treat files ending with 'Package' as library packages; other files as pages
         # Library packages must be rooted at <c:package> and have a name
         # Pages must NOT be named
         # An alternative would be to use different file extensions for library packages and pages
         $isPage = -not $file.BaseName.EndsWith("Package");

         if ($isPage) {

            $ns = $namespace

            if ($relativePath.Contains("/")) {
               $relativeDir = $startUri.MakeRelativeUri((New-Object Uri $file.DirectoryName)).OriginalString
               $ns = $ns + "." + (CleanIdentifier $relativeDir.Replace("/", "."))
            }

            $compiler.TargetClass = "_Page_$(CleanIdentifier $file.BaseName)"
            $compiler.TargetNamespace = $ns
            $compiler.TargetBaseTypes = "global::Xcst.Web.Mvc.XcstViewPage<dynamic>"
            $compiler.TargetVisibility = "internal"

            # Sets a:application-uri, used to generate Href() functions for each module
            $compiler.SetParameter("http://maxtoroq.github.io/XCST/application", "application-uri", $startUri)

         } else {
            $compiler.NamedPackage = $true
         }

         try {
            $xcstResult = $compiler.Compile((New-Object Uri $file.FullName))
         } catch [Xcst.Compiler.CompileException] {
            VisualStudioErrorLog $PSItem.Exception
            throw
         }

         $xcstResult.CompilationUnits | %{ $output.Write($_) }

         if ($isPage) {

            $pagePath = [IO.Path]::ChangeExtension($relativePath, [NullString]::Value)

            $output.WriteLine()
            $output.WriteLine()
            $output.WriteLine("namespace $($compiler.TargetNamespace) {")
            $output.WriteLine("$($compiler.IndentChars)[global::AspNetPrecompiled.Infrastructure.VirtualPath(""$pagePath"")]")
            $output.WriteLine("$($compiler.IndentChars)partial class $($compiler.TargetClass) { }")
            $output.Write("}")
         }
      }

   } finally {
      # Detach the event handler (not detaching can lead to stack overflow issues when closing PS)
      [AppDomain]::CurrentDomain.remove_AssemblyResolve($onAssemblyResolve)
   }
}

try {
   # Using a TextWriter as opposed to PowerShell's native output to configure end-of-line characters
   # Because XML parsers normalize CRLF to LF, we want to be consistent with the additional content we create
   $output = [IO.File]::CreateText((Join-Path (Get-Item .) xcst.generated.cs))
   $output.NewLine = "`n".ToCharArray()

   GeneratePackages $output

} finally {

   $output.Dispose()

   # Restore previous location (useful when calling script from command line)
   Pop-Location
}
